# JS中数组排序的方法有哪些

## 1. 方法1：选择排序（简单选择排序）

选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

### 1.1 算法步骤

>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
> <br/>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
> <br/>重复第二步，直到所有元素均排序完毕。

自述：①数组中的每一个元素和它后面的元素依次进行比较，第一轮找到的最大（最小）放在排序序列的起始位置；然后剩余的每一轮找到最大（最小）的数，将最大（最小的）元素放在已排序过的元素的后面。一个元素和后面的元素都比较完为一轮；重复以上步骤，直到完成。

### 1.2 代码示例

```javascript
let arr = [3, 57, 2, 8, 1,4];

for (let i = 0; i < arr.length-1; i++) {
//下标为i的元素和它之后的所有元素依次进行比较
    for(let j=i+1;j<arr.length;j++){
   //如果第一个比第二个大，就交换他们两个位置
        if(arr[i]>arr[j]){
            let temp=arr[i];
            arr[i]=arr[j];
            arr[j]=temp;
        }
    }
    console.log('第'+(i + 1)+'轮的排序结果',arr);
}
console.log('选择排序完成后的数组：',arr);

```

### 1.3 运行结果

```xml
第一轮的排序结果 [1,57,3,8,2,4]
第二轮的排序结果 [1,2,57,8,3,4]
第三轮的排序结果 [1,2,3,57,8,4]
第四轮的排序结果 [1,2,3,4,57,8]
第五轮的排序结果 [1,2,3,4,8,57]
选择排序完成后的数组：[1,2,3,4,8,57]

```

### 1.4 动图演示

![array-sort-01.gif](./images/array-sort-01.gif)

## 2. 方法2：冒泡排序

### 2.1 算法步骤
一次比较两个相邻的数，如果不符合规则互换位置，一次比较就能够将最大或最小的值放在数组最后一位， 继续对除最后一位之外的所有元素重复上述过程；

自述：

  比较相邻的元素。如果第一个比第二个大，就交换他们两个。

  对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。除了最后一个，针对所有的元素重复以上的步骤

  持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

### 2.2 代码示例

```javascript
let arr = [3, 57, 2, 8, 1, 4];
for (let i = 0; i < arr.length - 1; i++) {
    //每一轮要比较多少次
    for (let j = 0; j < arr.length - i - 1; j++) {
        //如果第一个比第二个大，就交换他们两个位置
        if (arr[j] > arr[j + 1]) {
            let temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
    console.log('第'+(i + 1)+'轮的排序结果',arr);
}
console.log('冒泡排序完成后的数组：', arr);

```

### 2.3 运行结果

```xml
第一轮的排序结果 [3,2,8,1,4,57]
第二轮的排序结果 [2,3,1,4,8,57]
第三轮的排序结果 [2,1,3,4,8,57]
第四轮的排序结果 [1,2,3,4,8,57]
第五轮的排序结果 [1,2,3,4,8,57]
选择排序完成后的数组：[1,2,3,4,8,57]

```

### 2.4 动图演示

![array-sort-02.gif](./images/array-sort-02.gif)

## 3. 方法3：插入排序

### 3.1 算法步骤

将数组第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
<br/>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。
<br/>如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。

### 3.2 代码示例

```javascript
//插入排序
let arr = [3, 57, 2, 8, 1, 4];
for (let i = 1; i < arr.length; i++) {
    let prevIndex = i - 1;//正在比较元素的前一个元素的下标（初始值）
    let current = arr[i];//需要和前面进行比较的元素
    // 当需要排序比较的元素的前一个元素比需要排序比较的元素大时
    while (prevIndex >= 0 && arr[prevIndex] > current) {
        arr[prevIndex + 1] = arr[prevIndex];
        //比较完后，继续和前面一个的元素比较，直至不满足条件
        prevIndex--;
    }
    arr[prevIndex + 1] = current;
    console.log('第'+(i)+'轮的排序结果',arr);
}
console.log('插入排序完成后的数组：', arr);

```

### 3.3 运行结果

```xml
第一轮的排序结果 [3,57,2,8,1,4]
第二轮的排序结果 [2,3,57,8,1,4]
第三轮的排序结果 [2,3,8,57,1,4]
第四轮的排序结果 [1,2,3,8,57,4]
第五轮的排序结果 [1,2,3,4,8,57]
选择排序完成后的数组：[1,2,3,4,8,57]

```

### 3.4 动图演示

![array-sort-03.gif](./images/array-sort-03.gif)

## 4. 方法4：快速排序(依托递归函数)

### 4.1 算法步骤

从数列中挑出一个元素，称为 “基准”（pivot）;
<br/>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
<br/>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

### 4.2 代码示例

```javascript
//快速排序
let arr = [3, 57, 2, 8, 1, 4];

//创建快速排序函数
function quickSort(tempArr) {
    //递归终止条件
    if (tempArr.length <= 1) {
        return tempArr;
    }
    //取基准
    let pivotIndex = Math.floor(tempArr.length / 2);
    //将获取到的基准的下标从元素组中删除并赋值给pivot
    let pivot = tempArr.splice(pivotIndex, 1);
    //分左右
    let leftArr = [];
    let rightArr = [];
    for (let i = 0; i < tempArr.length; i++) {
        if (tempArr[i] > pivot) {
            //满足条件的元素添加进rightArr这个数组
            rightArr.push(tempArr[i]);
        } else {
            leftArr.push(tempArr[i]);
        }
    }
    return quickSort(leftArr).concat(pivot, quickSort(rightArr));
}

console.log('快速排序后的数组',quickSort(arr));

```

### 4.3 运行结果

```xml
快速排序后的数组：[1,2,3,4,8,57]

```

### 4.4 动图演示

![array-sort-04.gif](./images/array-sort-04.gif)

## 5. 方法5：js中提供的sort()方法

sort()方法是数组自带的一种排序方法，默认情况下会将元素按照字符串进行比较。

### 5.1 基本思想

根据提供的排序规则，对数组元素进行排序。
<br/>使用数字排序，必须通过一个函数作为参数来调用。

### 5.2 代码示例

```javascript
//升序
function fun1(a, b) {
    return a - b;
}
//降序
function fun2(a, b) {
    return b - a;
}

console.log([3, 57, 2, 8, 1, 4].sort(fun1));
console.log([3, 57, 2, 8, 1, 4].sort(fun2));

```

### 5.3 运行结果

```xml
[1,2,3,4,8,57]
[57,8,4,3,2,1]

```